<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How Golang Connections are Made at a Kernel Level — Golang net pkg #2 - @martinomburajr</title>
        

        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../go/net-pkg/1-sockets-the-genesis-of-golang-connections-1/article.html"><strong aria-hidden="true">1.</strong> Go - Sockets: The Genesis of Golang Connections — Golang net pkg #1</a></li><li class="chapter-item expanded "><a href="../../../go/net-pkg/2-how-golang-connections-are-made-at-a-kernel-level/article.html" class="active"><strong aria-hidden="true">2.</strong> How Golang Connections are Made at a Kernel Level — Golang net pkg #2</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">@martinomburajr</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="banner.jpeg" alt="Server and Icon from Freepik | Router Icon from srip" /></p>
<p><strong>Author</strong>: Martin Ombura Jr.</p>
<p><strong>Date</strong>: May 21, 2019</p>
<h1><a class="header" href="#how-golang-connections-are-made-at-a-kernel-level--golang-net-pkg-2" id="how-golang-connections-are-made-at-a-kernel-level--golang-net-pkg-2">How Golang Connections are Made at a Kernel Level — Golang net pkg #2</a></h1>
<p>In <a href="../1-sockets-the-genesis-of-golang-connections-1/article.html">Part 1</a> of this series we introduced the idea of sockets, what they were,
common syscall APIs to creating and binding addresses to them. In this article
we introduce the other 3 core socket API methods and we visualize the connection
process between interconnected systems using the knowledge we gained.</p>
<h2><a class="header" href="#1-the-connect-listen-and-accept-socket-api-calls" id="1-the-connect-listen-and-accept-socket-api-calls">1. The Connect, Listen and Accept Socket API Calls</a></h2>
<p>In order to fully visualize how connections are set up, we need to introduce
three new socket API calls that will be of importance as we continue this
article series. These are <code>connect()</code>, <code>accept()</code> and <code>listen()</code></p>
<pre><code class="language-c">// Code Snippet 1: Connect() API Call
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<p>Connect is responsible for connecting a client with a server that is listening. The clients socket is referenced in the first argument sockfd and it connects to the servers bound address specified in the 2nd argument sockaddr. This is different from <code>bind()</code> as we saw in the previous article, that takes a socket and attaches a local address to it making it available from within the machine, whereas <code>connect()</code> has the ability to attach the address to a remote address that may want to use that socket to communicate. In most cases <code>bind()</code> would be used by a server to make its socket known, and <code>connect()</code> would be used by a <code>client()</code> to connect to the server. The 3rd argument is the addrlen that is simply used to specify the size of the addr <em>(2nd argument)</em>. If a <code>connect()</code> fails, it is good practice for the client to close the socket and attempt a new connection with a new socket.</p>
<h3><a class="header" href="#22-accept" id="22-accept">2.2 Accept</a></h3>
<pre><code class="language-c">// Code Snippet 2: Accept() API Call

#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<p>Accept is used to take an incoming connection on the listening socket indicated
by its socket file descriptor <code>sockfd</code> , it then creates a new socket and
returns the new file descriptor for new connections to read/write to. The
original socket that called <code>listen()</code> always remains open and can be used to
accept further connections. If there are no other connections, the call blocks
until new connections arrive.</p>
<h3><a class="header" href="#23-listen" id="23-listen">2.3 Listen</a></h3>
<pre><code class="language-c">// Code Snippet 3: Listen() API Call

#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int listen(int sockfd, int backlog);
</code></pre>
<p>Listen takes in the socket file descriptor <code>sockfd</code>, and marks that a socket as a
passive socket and is ready to accept incoming connections. Passive sockets
differ from active sockets in that when you create a socket with the <code>socket()</code>
command as shown in the previous article, these default to being active. This
active socket (client) can be used in a <code>connect()</code> call to create a connection to
a passive socket (server). The kernel can proceed to schedule other work as the
socket waits on a connection. The <code>backlog</code> argument defines a maximum queue
length of pending connections. If the number is exceeded the client can receive
a connection refused error.</p>
<p>Note: <code>listen()</code> cannot be re-applied to a connected socket that had a
successful <code>connect()</code> call from a client, or a socket returned by a call to
<code>accept()</code></p>
<h2><a class="header" href="#3-a-visualization-of-the-connection-process" id="3-a-visualization-of-the-connection-process">3. A Visualization of the Connection Process</a></h2>
<p>Now that we know the other pieces of the puzzle we can now visualize the
connection process between client and server. We shall use a connection-oriented
protocol like TCP <code>(SOCK_STREAM)</code> In <em>Figure 1</em> below we have two entities, a
client and server. Each entity contains a info-box with the calls its makes in
order to establish a usable connection-oriented transaction.</p>
<p><img src="tcp.png" alt="" /></p>
<p><strong>Figure 1:</strong> Photo from <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Bekeley Sockets</a></p>
<ol>
<li>Server Socket Creation and Binding: A server starts of by calling <code>socket()</code> to create a socket. This socket acts as an endpoint for communication and returns a file descriptor for the socket.</li>
<li>Binding the Socket to an address: The server then calls <code>bind()</code> to bind a well-known address which must be supplied to the socket. If not, the socket can not accept connections from any remote host. If <code>bind()</code> is not called, the kernel may apply a random host port to to make the socket available from localhost only.</li>
<li>Server Calls Listen: The <code>listen()</code> is invoked by the server to allow it to begin accepting connections. It moves the socket from an active to passive state. At this point a client can initiate a connection.</li>
<li>Client Creates a Socket: A client must create a socket to allow a connection to perform read/write operationson that socket. A SOCK_STREAM socket type enables a bidirectional streaming. When, the client chooses to create the socket is not as important as when the client decides to call <code>connect()</code> to the servers address.</li>
<li>Server Calls Accept: Once the server calls <code>accept()</code>, the server blocks until there is a connection from a client. In a multi-threaded environment, the thread will block until the server is terminated prematurely or a connection from a client is created.</li>
<li>Client Calls Connect: The client is free to call <code>connect()</code> at this point, passing in the servers address. The server is available and ready to accept connections as it is in the passive state ready to <code>accept()</code> connections. When the server responds it will use the address of the client that’s stored in a network header (usually IP header). If the client calls <code>connect()</code> before the server calls <code>accept()</code> but after the server calls <code>listen()</code>, the connect would be added to the listeners backlog, if the backlog limit has been reached, the connection will be refused.</li>
<li>Client Write and Server Read: The client and server can begin to write to to the connection as if writing to a file. This abstraction of reading and writing to a connection as if it were a file is crucial to understanding low-level IO, and it will spring up quite often in subsequent articles. For now it is important to know the client sends a request by writing to the connection, the server reads the written data stream, and responds with another write to the connection. We shall look at the intricacies of reading and writing in a later article, but for now, keep in mind writing to a connection is inherently the same as writing to a file. The term file to the designers of unix tends to have a more abstract meaning than that of the way we use day to day.
Connection Termination: A connection can be terminated for several reasons,
either client or server terminating the connection, higher-level timeouts on
connections being sent, extraneous errors, connections on the <code>listen()</code> backlog
overflowing etc.</li>
</ol>
<p>This back and forth on a connection-oriented protocol may remind you of an image
you may have seen when learning TCP. That is because I have just described the
TCP connection flow to you using unix based syscalls, instead of SYN, ACKs etc
<em>(See Figure 2)</em>.</p>
<p align="center">
  <img align="center" src="tcp_2.gif" alt="TCP Connection Flow taken from IBM">
</p>
<p>This is what happens under the hood when Go initiates connection-oriented client-server interactions. In the next article we begin to explore the idea of file descriptors a bit more and how connections have striking similarities to files.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../go/net-pkg/1-sockets-the-genesis-of-golang-connections-1/article.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../go/net-pkg/1-sockets-the-genesis-of-golang-connections-1/article.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
